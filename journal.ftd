-- import: ft
-- import: config
-- import: fpm

-- ft.doc-page:
toc: $config.dev-toc
id: page


-- ft.h0: FTD Journal

-- ft.h1: Dynamic Components: Path Ahead

21st Jan 2022

Now that we have basic dynamic components working, we need to think of syntax
for more actions. We currently has "SQL-esque" commands, eg `increment $foo by 1`
etc, instead of function like syntax: `$foo.increment(by: 1)`. We have to figure
out what we want our eventual syntax to look like.

Some command operations:

1. increment an integer variable: `increment $foo by $incr clamp 10`.
1. Updating a variable: `$foo=<new value>`.
1. Toggling a boolean: `toggle $foo`
1. Inserting an element into a list: `insert $el into $list at end` or `at front`
   or `at <position>`.
1. Clearing a list or an optional value: `clear $list` or `clear $optional`
1. Removing element at given position: `remove from $list at $pos`


-- ft.code:
lang: ftd

\-- ftd.text: hello
$event-click$: increment: what=$count, by=2
> what: $count
> by: 2
> clamp: 10

\-- ftd.text: hello
$event-click$: increment: what=$count, by=2, clamp=10

-- ft.markdown:

Moving to a function call syntax looks good. We have to prefix functions by their
module names, so most of functions provided by `ftd` will be `ftd.<foo>`.
Arguments will always be named, no positional arguments. We will use `=` for
arguments that come on same line, and `:` for arguments that come in subsequent
lines. Functions can define `caption` type, in such cases, other arguments can
not come in caption line.

-- ft.h2: Function Syntax Basics

One possible way to implement functions could be:

-- ft.code:
lang: ftd

\-- void increment:
integer variable what:
integer by: 1
optional integer clamp:

integer new = $what + $by

if $clamp && $new > $clamp {
    $new = 0
}

$what = $new

-- ft.markdown:

The type of a function is in the declaration line. We have created a special type
`void` for functions that are only for side effects, e.g. to be directly called
from `$event-*$`. For other types, eg integer it will appear to look like an
integer variable definition, but since it takes arguments, it's a function.

The last expression can be considered the return type of a function, but we will
also support `return <value>`. Arguments are specified in usual manner.

-- ft.h2: Higher Order Variables

In the example we have used `integer variable what`, which is to indicate that
here we are not accepting a value, but the reference to some variable, which
would be modified by this function.

-- ft.h2: Functions Vs Formula

Functions would be called from event handlers. Functions job is to mutate some
variables.

Some functions can be defined as pure, they can not take higher order variable,
and can only be called from variables defined at global levels. Formulas can
depend on other variables, and when the underlying variable changes, the value
of the formula changes automatically.

-- ft.code:
lang: ftd

\-- integer length: 20

\-- integer foo: area: length=$length, width=20

-- ft.markdown:

Here since the declaration of a variable uses a function, `foo` is considered a
formula. In such cases further updates to `foo` is not allowed. If `$length`
changes, `foo` would be auto-updated.

-- ft.h2: Error Handling

We are basically stuck here right now. What is you try to remove the 10th item
from a list, but the list only contains 2 items? Should it silently be dropped?
We do type checks, so we do not have to worry all sorts of errors, so you can
not add a string to an integer array, this will be checked at "compile time", if
you try to do that, the document would fail to load. But run time errors can
still happen.

Variables change from events. What kind of errors: division by zero. Parsing
error, e.g. if someone is trying to enter an integer in an input field, and they
type some non digit. Or say if we are reading some data from JSON, and we are
expecting an integer but we get a string, or the key is missing.

Among these errors I listed, divide by zero is special, in being an operation
that we usually don't want to make "error check before proceeding", for others
we can ensure all functions that can fail return some value that forces one to
handle failure possibility. Forcing error check for divide by zero will force
all mathy code to become too verbose.

Any error that happened during initial page load is "fine", we simply bail, show
error message and let author figure it out. This is equivalent to "compile time",
and we want people to not store invalid documents. But runtime errors we can not
avoid.

-- ft.h3: Rust Like `Result` And `Option`

Rust has first class for failures, `Result` and `Option` types are there. It kind
of means we need some level of generic support. We can have special handling for
Result and Option types without generic.

So we can write something like:

-- ft.code:
lang: ftd

\-- integer result to-integer:
string value:

-- ft.markdown:

Here we have a function `to-return` that returns `integer result`, (for list it
would be `integer list result foo:`).

-- ft.h3: Handling Errors

`if <var-name> = <result expression> { success clause, can use <var-name> }
else <error-name> { error clause }`

-- ft.code:
lang: ftd

\-- void foo:

let i = if num = to-string: value=hello {
    num
} else error {
    console.log(error)
}

-- ft.markdown:

Can also work with optional values. Function can return `-- optional integer foo:`
optional values as well. In such cases, the `else` block won't take `error`
variable name, it will always be null.

Error type will only be string. In future when we have enums, we can also do:

-- ft.code:
lang: ftd

\-- string enum Errors:
invalid-integer: Value Is Not A Valid Integer
empty-value: The value was empty string
overflow: The value is too large to fit into integer type.


\-- void foo:

let i = if num = to-string: value=hello {
    num
} else Errors.invalid-integer {
    console.log(Errors.invalid-integer.message)
} else Errors.empty-value {
    console.log(Errors.empty-value.message)
} else error {
    console.log(error)
}

-- ft.markdown:

Here we have multiple else clauses for `enum`.

-- ft.h2: `<type> result` is not an `or-type`

`or-type` is our name for `enum` in Rust.

In future we will have `match` statement for handling `or-type`, but we are not
going to treat `result` and `optional` as `or-type`, so `match` can never work
with them.

-- ft.h2: Returning Errors

We will use `return 1` to indicate success, and `fail "whatever the message`
to return failure message. We will also support `let num = to-string?
value=hello`, here `?` acts like Rust.

-- ft.h2: Event Handler Errors

What happens if one of the event handlers raises an error? One option is we do
not allow functions that can fail as event handlers.


-- ft.h2: Old Notes

insert syntax, clear, delete at index, is list empty, how many items in the
list, similarly how to filter

default record

-- ft.code:
lang: ftd


\-- void do-get:

fetch-people(after-get, on-error)

\-- void fetch-people:
success(person list) -> void:
failure error->void:

ftd.http-get("https://foo.com", success, failure)



\-- void after-get:
person list people:

\-- void on-error:
error error:





-- ft.h1: Dynamic Components Landed!

19th Jan 2022

Till now when a page used to get rendered from backend, it used to contain the
entire component hierarchy, and front-end event handling etc only changed some
of the DOM attributes, and visibility. If there was an element whose visibility
was affected by an `if` clause, it used to be always included, and set as hidden
and when needed we used to make it visible. We never created DOM node till now
as part of event handling. This means it was not possible for us to have say a
list, and add elements to the list from any of our event handling code.

Yesterday Arpita implemented support for dynamically constructing DOM when say
we add elements to a list.

Consider this:

-- string list strings:

-- optional string query:

-- ftd.column:
spacing: 10

-- ftd.row:
width: fill
spacing: 10

--- ftd.input:
placeholder: Type Something Here...
width: 250
border-width: 2
padding: 8
$event-input$: $query=$VALUE

--- ftd.text: Add
if: $query is not null
color: white
background-color: green
move-down: 4
padding: 5
$event-click$: insert into $strings value $query at end
$event-click$: clear $query

--- ftd.text: Clear
color: white
background-color: red
move-down: 4
padding: 5
$event-click$: clear $strings


-- ftd.text:
if: $query is not null
color if $fpm.dark-mode: white

You have typed: {value}

--- ftd.text value: $query
color: green
color if $fpm.dark-mode: white
background-color if $fpm.dark-mode: green
padding if $query is not null: 5
size: 20


-- show-data: $obj
$loop$: $strings as $obj


-- ftd.column show-data:
caption text:
padding: 10
/background-color if $fpm.dark-mode: white
background-color: yellow
color: red

--- ftd.column:
padding: 20
border-width: 2

--- ftd.text: $text

-- container: page

-- ft.markdown:

We are very proud of this feature! What is even cooler is how little work it
took to implement it. Initially I thought we will have to somehow send our
component spec to front-end, for the components that are directly or indirectly
called from the components used by such dynamic elements we want to create. And
it sounded like a lot of duplication of logic between what we do in Rust and we
would have to do in JavaScript.

Arpita got this brilliant insight that we can create one instance of each such
component and keep them hidden, and when we have to create any new instance of
any of these components we clone that DOM node, and set it up with correct data.

It turned out to be as simple it sounds, and entire insight to merge was 3-4hrs!
I was worried about JS size increase etc, and none of that happened. So little
code, such a massive impact.

Now that we have support for creating nodes dynamically, we are almost complete
UI solution, and FTD should be considered an alternative anywhere you would
consider using say React for creating UI.

-- ft.h1: "$main$" Variables

18th Jan 2022

Some variables, like `fpm.document-title`, could be set by more than one ftd
documents, each document is telling us what is the document-title for that
document by setting `fpm.document-title`.

But we allow authors to import any document from any other document, barring
cycles, so these variables can get clobbered. Say if there is `a.ftd` and `b.ftd`
and former wants document title to `A` and later to `B`, they can do both:
`-- fpm.document-title: A` and so on. But what if `a.ftd` looks like this:

-- ft.code:
lang: ftd

\-- import: fpm

\-- fpm.document-title: A

\-- import: b

-- ft.markdown:

`b.ftd` would be imported after `a.ftd` has updated `fpm.document-title`, and
it will overwrite `fpm.document-title`. We can argue this is fine at some level
and user is aware of things.

Further there is another concern, what if `fpm.document-title` was optional, and
the idea was if this is not set, we pick the title from first heading of the
document. And say this worked out fine, so `a.ftd` will not want to
`fpm.document-title`, but say it does not work for `b.ftd` so it wants to
explicitly set it. But then `a.ftd` imports `b.ftd`. We can not solve by import
order etc.

Proposal:

-- ft.code: `fpm.ftd` file
lang: ftd

\-- optional string document-title:
$main$: true

-- ft.markdown:

If any variable or list is defined as `$main$`, then only the changes done by
the "main document" would be kept. FTD interpreter knows whats the main document
that is being interpreted, and it knows when it is interpreting one of its
dependencies (via import).

We can further allow `$main$` during variable change also to allow non main
documents to update variable still, eg a `config.ftd` or some file which is
only for setting project variables.

-- ft.code: `config.ftd`
lang: ftd

\-- import: fpm
\-- fpm.site-title: AmitU's Blog
$main$: true

-- ft.markdown:

Further when any "main" document is importing some document, it can declare that
that document be also considered main:

-- ft.code: `a.ftd`
lang: ftd

\-- import: config
$main$: true
\-- import: b

-- ft.markdown:

Here we have imported `config` as "main", but not `b`.

This would be applicable for both variable overwrite, and for adding a an element
to a list, either can use "$main$".

-- ft.h2: In Other Words

1. some variables can be declared as $main$.
1. a `$main$` variable can only be modified by
   1. document that is considered `$main$`, 3. and 4. decide when a document is
      considered `$main$`
   1. or by forcing update by include `$main$` while updating the variable
1. the document that started the interpreter is the initial `$main$` document
1. when a `$main$` document is importing some document it can declare those
   document as `$main$` as well

-- ft.h2: Edge Case

Consider if `b.ftd`:

-- ft.code:
lang: ftd

\-- import: fpm
\-- fpm.document-title: B

\-- ftd.text show-title: $fpm.title


-- ft.markdown:

And say `a.ftd` was:

-- ft.code:
lang: ftd

\-- import: fpm
\-- fpm.document-title: A
\-- import: b
\-- b.show-title:

-- ft.markdown:

The `show-title` will show `A` and not `B` even though if you look at source
of `show-title` in `b.ftd` it appears it is modifying a variable and using it
right away.

This is not particularly confusing because a variable could have been updated
multiple times, even within the same file:

-- ft.code:
lang: ftd

\-- import: fpm
\-- fpm.document-title: B

\-- ftd.text show-title: $fpm.title

\-- fpm.document-title: New B

-- ft.markdown:

In this case, the immediate value of `fpm.document-title` is not used by
`show-title`, but the "eventual value".

-- ft.h1: Object Gets `$ref` syntax

Arpita implemented variable referencing in object constructor syntax, so now
you can do:

-- ft.code:
lang: ftd

\-- import: bar
\-- object foo:
key: $bar.baz

-- ft.markdown:

And say if `bar.baz` is `20` (`integer`), it will generate this:

-- ft.code:
lang: json

{
    "key": 20
}

-- ft.h1: Proposal: `message-host` to only accepts objects

This brings use to `message-host`. It currently accepts either a string, which
is the name of function exposed by the FTD host, or it can be an object, that
has to define a key `function`, which will be the function.

In general I am not fond of "string values", because if you make a typo, ftd
interpreter can't help you. The host functions are provided by host language,
and ftd compiler has no idea about host functions. Ideally FTD compiler should
have some knowledge about capabilities provided by host, maybe some sort of
schema and type definition?

In the meanwhile, accepting both string and object, I now consider an
anti-pattern, we should only support well known object constructors:

-- ft.code:
lang: ftd

\-- import: fpm

\-- ftd.text: Switch To Dark Mode
$event-click$: message-host $fpm.switch-to-dark-mode

-- ft.markdown:

Is superior to `message-host switch-to-dark-mode`, where `switch-to-dark-mode`
was a string, but `$fpm.switch-to-dark-mode` is a reference to something FTD
interpreter can verify.

-- ft.h1: `$processor$`, `async`, `Library::get()` and `Document::set_*()`

16th Jan 2022

One of the things that has emerged since yesterdays brain storm with Arpita is
we need first class support for updating FTD variables from "host languages".

You can say we have already two host languages, Rust and JavaScript. Once a
variable has been defined in FTD it can be updated by by Rust code on backend
using `ftd::Document::set_bool()` etc family of functions. Similarly the variable
can be updated by `window.ftd.set_bool()` etc family of functions.

So we have an emerging pattern, we define some variables in FTD with some initial
values, and they can be made dynamic by host. If we make this a first class thing,
currently we only support changes to basic types like boolean and string, if we
support complete access to FTD internals from host, and reliably update the FTD
"view" based on FTD data it would be cool.

-- ft.h2: `Library::get()` Simplification

Currently we have a technique where we create "virtual" FTD documents, e.g. there
is a module `fpm` for our FPM static site generator. This module is dynamically
constructed with actual values set for all these variables. This is done so we
can pass a bunch of data that we have in Rust to FTD files. So we do something
like [this](https://github.com/FifthTry/fpm/blob/8a0ce82571921e275292532b211a2dcaad618131/src/library/mod.rs#L136-L336):

-- ft.code: dynamically generating `last_modified_on`
lang: rs

format!(
    indoc::indoc! {"
        -- record ui-data:
        string last-modified-on:

        -- ui-data ui:
        last-modified-on: {last_modified_on}
     "},
    last_modified_on = fpm::i18n::translation::search(
        &lang,
        &primary_lang,
        "last-modified-on",
        &current_document_last_modified_on
    ),
)

-- ft.markdown:

We are setting `last_modified_on` based on string substitution in Rust using
`format!()` statement.

If we have first class support for setting any variable from Rust, we can keep
`fpm.ftd` file static, with no data in it, and load it to create FTD variables,
and then update each of the variables defined by `fpm.ftd` file.

This means our `ftd::Library::get()` methods can be simplified. It currently
perform two tasks:

1. Given an ID, it transforms the ID, e.g. it looks up the ID in dependency list,
   applies complex module resolution logic and reads the final file from disc.
2. It generates dynamic ftd files like I shown above.

The transformation etc can be done in a `sync` way. Reading a file itself can
be argued to be `async`, but for many cases it can be considered sync, say if
you have an in-memory database of ftd files.

Point is, if we recommended use case 2, it would necessarily mean `ftd::Library::get()`
be strongly `async`, allow arbitrary complex data lookups, HTTP API calls, database
calls and so on. Where as if `::get()` is only for loading FTD files, it's relatively
simpler. In many many use cases, say for serving blog or static content, content
is small and can be read on application start, with some watcher to keep updating
in memory cache on file system changes. In other cases, say FTD working as
primary front-end for application, the number of FTD files would be even smaller
in general. So it is conceivable to keep entire set of FTD files in memory.

This will still leave out fetching FTD files from say internet. If we want to
support that, and there may be some security issues there, but maybe they are
solvable somehow and in general we should allow fetching from internet etc.

So while we can not fully make `ftd::Library::get()` `sync`, at least we can
limit it's complexity, and not have two ways to set dynamic data.

-- ft.h2: Reviewing `$processor$`

So if we have first class support for update FTD data from host languages, then
do we still need `$processor$`?

Our `ftd::Library` Rust `trait` exposes another method `::process()` whenever
FTD interpreter encounters a `$processor$` directive. `process()` computes the
data, and passes it to interpreter, and then interpreter continues interpreting
the rest of the document.

Technically we can make this also two pass, let the interpreter interpret the
entire document in peace (only interrupted by `::get()` calls, to be executed
every time interpreter comes across an `-- import:` directive).

We are basically seeing if we can make the whole interpret pass "pure
computation". Now we proved `get()` can't be pure yet and we probably will accept
that design choice. But what about `$processor$`? Can we remove it?

One key difference between `fpm` scenario I described above vs `$processor$` is
`fpm` was "well known". `fpm` module is well documented (or is going to be), and
so Rust code knows what all dynamic variables are there, and Rust can update them.

But in case of `$processor$`, it can be applied on any user variable defined in
arbitrary FTD file. Interpreter can give each of `$processor$` variables a
default value, go through the document once, and afterwards let Rust update it
How would Rust know what all variables to update?

-- ft.code: `$processor$` to update variable
lang: ftd

\-- string foo:
$processor$: get-some-data-from-internet

-- ft.markdown:

Here we have a processor `get-some-data-from-internet`, which returns a `string`,
and the string is bound to the name `foo` in FTD.

Currently when interpreter encounters `$processor$` directive, it immediately
calls the `get-some-data-from-internet` (via `Library::process()`), and
initializes `foo`.

If we want to do it after the fact, we would have to discover what all variables
have processor applied.

We have another use case of processor planned:

-- ft.code: `$processor$` to component
lang: ftd

\-- ftd.text:
$processor$: get-some-data-from-internet

-- ft.markdown:

In this case we are not keeping the output of `get-some-data-from-internet` in
any FTD variable, but instead directly passing the value to the component.

Currently there is no plan to allow host to directly modify the FTD generated
DOM, we want to do it via data updates, host only knows about data, updates the
data, and UI updates itself.

On the whole it feels to me that creating new API to get variables that have
`$processor$` or worse allowing host to directly update DOM are not great ideas.

So our interpreter can not really be pure data operation, and it seems the best
design is to allow for first class `async` support and continue on current path.



-- ft.h1: Object Implementation Details

15th Jan 2022

So Arpita has just implemented object constructors:

-- ft.code:
lang: ftd

\-- object obj:
function: console-print
value: Hello World

-- ft.markdown:

With this now you can construct JSON objects, eg above will create:

-- ft.code:
lang: json

{
    "function": "console-print",
    "value": "Hello World"
}

-- ft.markdown:

And then you can pass the object to JavaScript using `message-host`, eg:

-- ft.code:
lang: ftd

\-- ftd.text: click me
$event-click$: message-host $obj

-- ft.markdown:

And in JavaScript you can write the consumer:

-- ft.code:
lang: js

window["console-print"] = function(v) {
    console.log(v.value);
}

-- ft.markdown:

This JS code has to be provided by the "FTD Host", eg FPM is one such FTD Host.
To create arbitrary functionality, FTD Host interface has to be implemented.


This is the basic. Soon the object constructor will be able to refer to other
variables in FTD, eg:

-- ft.code:
lang: ftd

\-- object obj:
function: console-print
value: $foo

-- ft.markdown:

Here we will use the value, and type of `$foo`, and that will be inserted in the
object.

-- ft.h2: Objects Are Opaque

One important point to note is that objects, once constructed, can not be
introspected from FTD. So you can not do:

-- ft.code:
lang: ftd

\-- integer f: $obj.value

-- ft.markdown:

Assuming `$object.value` is an `integer`, this may seem "reasonable", but we do
not allow it. At least for now. We are doing it for performance reason one can
say, also we are lazy, we do not yet have time to think though the implications
of it.

We are building this feature to pass data to JavaScript for now, so we are
committing to only the part of design that is minimally needed.

-- ft.h2: JS Evaluation

When we have variable references in the object, we will generate the following
object:

-- ft.code:
lang: json

{
    "object": {
        "function": "console-print",
        "value": "$foo"
    }
}


-- ft.markdown:

We have one option that we go through the object and find all values with `$foo`
pattern, and resolve them. We can also have `\$foo` to escape this behaviour.

Other option is to keep track of references:

-- ft.code:
lang: json

{
    "references": {
        "value": "$foo",
        "foo.bar[0].baz": "$baz"
    },
    "object": {
        "function": "console-print",
        "value": "$foo"
    }
}

-- ft.markdown:

In `references` we have "JSON-paths" to every key that is a reference. Its easy
to update the object by iterating it.

We will see which ends up being easier to implement.

-- ft.h2: Objects Are Only Constructed in JS

The optimization I was talking about, why we want things opaque in FTD is so that
we only write code to create "object" in JS, and we do not have to evaluate the
value of object in Rust at all.

-- ft.h2: JavaScript Is Not The Only Host Language

Currently we are writing our FTD Host implementations in JS, but tomorrow we
want to support Swift, Java, etc when FTD targets other platforms.

This is why FTD is trying to be a common language that will work everywhere, it
will be responsible for UI and all the core part of functionality, like search,
API access etc, has to be provided by host.

-- ft.h2: Objects Can Take Parameters

You may want to pass parameters to objects. Soon you will be able to do:

-- ft.code:
lang: ftd

\-- object console-print:
string message:
function: console-print
message: $message

\-- ftd.text: click me
$event-click$: message-host console-print:
> message: clicked!

\-- ftd.input:
$event-input$: message-host console-print:
> message: $VALUE


-- ft.markdown:

Other usage of object constructor that takes parameter would be:

-- ft.code:
lang: ftd

\-- object get-user-info:
string username:
$process$: http
url: https://github.com/api/user-info
method: POST
api-key: $api-key

\-- user-info info:
$processor$: get-user-info
username: amitu

-- ft.h2: `message-host` can now pass parameters to FTD Host

`message-host` till now used to accept a function name, and `ftd.js` used to call
that function.


-- ft.code:
lang: ftd

\-- ftd.text: click me
$event-click$: message-host foo

-- ft.markdown:

This will call a function named `window.foo()`.

But there was no way till now to pass arguments to that function. With the
latest changes done by Arpita now we can pass arguments as well:

-- ft.code:
lang: ftd

\-- object arg:
function: what-ever-function
name: jack
field: value

\-- ftd.text: click me
$event-click$: message-host $arg

-- ft.markdown:

With this we will call `window.what-ever-function` and pass it following object:

-- ft.code:
lang: json

{
    "function": "what-ever-function",
    "name": "jack",
    "field": "value"
}

-- ft.markdown:

We will soon allow including FTD variable references in the object, e.g.
`name: $name`. We will also make `function` optional, if it's not passed we will
assume the name of object, in the above example it was `arg`.

-- ft.h1: `$VALUE` on `ftd.input`, `$event-input$` and `$event-change`

Arpita added support for `$VALUE` special variable so now you can do:

-- ft.code:
lang: ftd

\-- optional string query:

\-- ftd.input:
placeholder: Type Something Here...
$event-input$: $query=$VALUE

\-- ftd.text: $query

-- ft.markdown:

With the above, whatever is typed in the input field is immediately reflected
in `$query`. See a [demo here](https://fifthtry.github.io/ftd/input.html).

We have two events, `$event-input$`, which happens as soon as a input is edited,
on key press, and `$event-change$`, which happens when the user presses Enter
after inputting, or if the input field loses focus.

The `$VALUE` special variable is only visible to the event handler of the above
two events.

-- ft.h2: Future Plans

In future we will add a few features:

-- ft.h3: `value`

-- ft.code:
lang: ftd

\-- ftd.input:
value: $query
$event-input$: $query=$VALUE

-- ft.markdown:

Note the `value` bound to a variable, every time the variable changes the value
of the input field would be updated. So you can control the value of one input
field with another for example.

-- ft.h3: `default`

-- ft.code:
lang: ftd

\-- ftd.input:
default: $query

-- ft.markdown:

`default` will be used to bind the value of an input field when the input field
is initialized, and any further changes done to `$query` would have no effect on
the input field.

-- ft.h3: `type`

We will also support `type` parameter so input field can be used to get `username`,
which hints the browser to use Password Manager etc, `email`, `password` etc,
similar to how HTML input works.

-- ft.h1: Missing Feature: Intra-Page Table Of Content

When a FTD generated page is created, it is currently not possible to create a
table of content based on headings in the page.

Many sites show a table of content somewhere, usually on the right, or sometime
at the beginning of the article after the intro etc. This requires us to query
the current page for data. Heading hierarchy is one such data. List of images,
tables, diagrams etc could be other such query. Maybe even list of all foot-notes,
links etc could be useful as well.

We have "region" to identify some of these things. The query should allow us to
query by region, and authors should use regions properly to set this up.

One way to query things is package-query feature that we are working on `fpm`.
But that is largely for querying information from the entire package. And while
one can use the same mechanism to also query for information in current page, it
puts a dependency on `fpm`. Since ftd has access to information in current page,
such a query can be conceivably be easily provided by FTD as well.

What would be the result to these queries? Since these queries are to power intra
page linking, they should return `#hash` for that specific DOM node. We auto
generate `id` for each heading as of now. We have to start generating IDs for
every interesting region.

So the query could return list of hash, title pairs. Each region will have to
be associated with some sort of text as well. In case of image, table etc it
could be caption. Else it the name of the object can be the title, e.g. for image
we will just show "image", or even "image 1" etc.

What about heading tree?

We already do heading tree detection, we can return a nested data structure based
on our query.

What all to include? We can pass a list of regions that we are interested in.

It has to be a `$processor$`. We can call it `page-query`, `package-query` for
entire package, page query for just the page.

-- ft.code:
lang: ftd

\-- ftd.toc-item list headers:
$processor$: page-query
regions: h1, h2, h3, h4, image, table

-- ft.markdown:

Where `ftd.toc-item` itself is a record:

-- ft.code:
lang: ftd

\-- record toc-item:
string title:
string url:
toc-item list children:

-- ft.markdown:

Implementing it requires two pass rendering. In first pass the data would be
wrong, an empty list, we will first construct the whole DOM tree. And then in
second pass we will do the query, and update the list with the result.

-- ft.h1: TODO, RELEASE Only Posts And So On

In org-mode it is possible to add some tags to headings, like a TODO, RELEASE
etc, and then do query on the tags, eg only show headings matching given tag.

Consider this journal page itself, there are a lot of future TODO like headings,
many announcements of some feature RELEASE and so on. Now imagine if there was
some way to have a selector where you click on TODO button and only the posts
with TODO tags are visible.

How would we do that? One easy way to do it is to create components like this:

-- ft.code:
lang: ftd

\-- optional string current-tag:

\-- ftd.text h1: $title
caption title:
string tags:
if: $current-tag is null | $tags contains $current-tag

-- ft.markdown:

This should be doable already with no feature requirements, other than the `|`,
the `or` expression support.

-- ft.h1: Tags In TOC

It would also be cool if we could show the tags in the TOC. But our type
`toc-item` does not have `tags`. `region` is a common property, available on
all ftd elements. Maybe we can add `tags` on all of them as well, and include
`tags` in `toc-item`? We should also add `region` to `toc-item`.

-- ft.h1: Min/Max And Other Constraints

I was reading up on asn1, and they have interesting feature:

-- ft.code:
lang: asn

Address ::= SEQUENCE {
   street-address UTF8String,
   country UTF8String -- see a note below,
   postal-code UTF8String
} ((WITH COMPONENTS {
       ...,
       country ("USA"),
       postal-code (PATTERN "[0-9]#5(-[0-9]#4)?")
    }
  | WITH COMPONENTS {
       ...,
       country ("Canada"),
       postal-code (PATTERN "[0-9][A-Z][0-9]
                                [A-Z][0-9][A-Z]")
    }
  ))


-- ft.markdown:

SEQUENCE is just a `record`, and it has three fields, and for `postal-code` they
have two different constraints applied, depending on the value of `country`
field, e.g. if `country` is `USA`, then `postal-code` must match the given pattern
and so on.

This is quite interesting. We have minimal form handling support now, so user
is going to type stuff, and it would be good if we can chose to not accept
invalid values.

Similarly for components and theme configuration variables theme and component
authors should be able to place some restrictions on the values passed to them.

How could could it look like? First of all it has to be done at both top level,
and inside component level. So like `-- container:`, which can equally well work
with `--- container:`, meaning it should not have nesting. If we look at ASN1
example there is clear nesting. I mean if there was no nesting it would be easier
to design. Lets see.

Say:

-- ft.code:
lang: ftd

\-- string foo: hello


\-- check foo for person:
\--- title:
regex: <some regex>

-- ft.markdown:

So I am proposing a `check` keyword. We could have called it `constraint foo`
as well, but that's longer to type and I keep forgetting the spelling.

We can do it on record as well:

-- ft.code:
lang: ftd

\-- record foo:
string title:

\--- check title:
regex: <whatever>

-- ft.markdown:

And for components:

-- ft.code:
lang: ftd

\-- ftd.text foo:
caption title:

\--- check title:
regex: <whatever>

\--- check p:
check: foo

-- ft.markdown:

Types of checks will vary based on type of thing being checked. For string we
have `regex`. But we can have `max-length`, `min-length`, `starts-with`,
`ends-with`, `is-lower-case`, `is-title-case`, `contains`/`at-most-one` and so
on. Maybe even `unicode-range` stuff we use for `font-face`.

Similarly `integer` can be `min`, `max`, `is-odd: true`, `is-prime`? etc.

`contains`, `min`/`max` etc can also refer to other variables. How would we
disambiguate global vs local variables by same name? We won't. Don't overwrite
shadow variables, it's not a good idea, we will put a lint for that.

How would we know if the value is failing? In some cases we can create errors,
so if an invalid value was part of a document we can refuse to save the document
etc. But sometimes, e.g. when I am say changing a `boolean`, and based on new
value of the `boolean` a bunch of variables that were initially valid are no
longer valid. How do we deal with that?

One option is we accept the error case, and for each variable we have a special
attribute `.error`, which can be `optional string`, will be `null` if the
variable checks pass, else it would be the user visible error message.

Error message in what language? We can't pretend there is only one language now
can we? Especially when first class translation support is our one of shining
features in `fpm`? Problem for tomorrow me!

`-- check` can specify some error message as well if the check fails. What if
there are more than one errors? Make it `.errors`, like Django forms? Auto
message, e.g. failure of `min`, we can create an error message in right language.

-- ft.h1: Thoughts On Internationalization in FTD

BTW this takes us to need for ftl, Fluent, like way to translate stuff, when
we are creating component libraries, we are going to have to hard code strings,
and given we have first class `markup` support, we can create string templates
in every language for some string, and use variable substitution etc.

-- ft.code:
lang: ftd

\-- ftd.text welcome-message:
string who:
text if $fpm.lang == en: Hello, {$who}

\--- text:
if $fpm.lang == hi:

नमस्ते {$who},

आपसे मिल कर बहुत ख़ुशी हुई.

-- ft.markdown:

Some polish is needed in the syntax, but I think it can be made to work without
adding any new feature to FTD for translation.

-- ft.h1: `$event-click$: message-host <>`

23rd Dec 2021

Arpita just implemented [`message-host` event handler](/ftd/~/127/) support. Now
the "ftd host" (we will rename `ftd::Library` to `ftd::Host` terminology soon), can
define a JavaScript function (and in future when we support iOS etc, register Swift
function etc) and call it as event handler from FTD documents:


-- ft.code: defining the `foo()` host method
lang: js

window.foo = function() {
    console.log("foo");
}


-- ft.code: calling the `foo()` host method
lang: ftd

\-- ftd.text: call foo
$event-click$: message-host foo


-- ft.markdown:

Current we do not pass any arguments to the function. In future, when [json
constructor](/ftd/~/122/) is ready we would be able to pass FTD variables to host
functions.


-- ft.h1: Giving up on Special Variables

6th Dec 2021

Was writing a CR about ["fpm actions"](https://www.fifthtry.com/fpm/~/24/), and my
initial thought was to expose form errors using special variables, but then I
realised we do not have a mechanism to register for changes in [special
variables](/ftd/~/121/).

Variable change can only happen on client (it can still be triggered by server
and sent to client, eg on WebSocket). We are going to have `fpm.js` file to handle
those variables. We already have methods in `ftd.js` to update any variable, and
already have variable dependency tracker that updates the rendered DOM tree in an
efficient way.


-- ft.h2: What about "heavy variables"?

If we are creating regular variables, do we create a single virtual document that
exposes all the variables? Wouldn't computing that document be expensive? What if
we do not even use them?

One simple answer is to not have a single virtual document, but have a bunch of
document, maybe even one document per variable in extreme case. So we only import
the document that we want to use.

We will also have a linter that will complain if a document is imported but not
used, (and therefore we have [`import: foo as _`](///ftd.dev/~/44/) syntax).


-- ft.h2: "FTD Host"

FPM is proving to be a very good playground to explore what is the meaning of a FTD
Host. We have the `.get()` method, and FPM is putting a lot of interesting logic
in it, so this part of design is proving fruitful. Then we need special documents
for "generated" variables, and ftd host will take care of updating them on client
if needed.

FPM also exposes processors, and that's also working out quite well, there are very
FPM specific processors.

This does mean there is issue with portability of FTD documents between different
"FTD Hosts", would we have more than one hosts of FPM would be the only host?

We have at least one contender for next FTD host: arbit pages. If you want to use
ftd to power say your homepage (without using `fpm-repo`), and you must consider,
you are going to need your own variables with your own way of fetching documents
and your own


-- ft.h1: Unified Component Syntax

3rd Dec 2021

Arpita has implemented a unified syntax for component creation.


-- ft.code: old syntax
lang: ftd

\-- ftd.row foo:
spacing: 20


-- ft.code: new syntax
lang: ftd

\-- ftd.row foo:
spacing: 20


-- ft.markdown:

This was done to make it uniform with declaring variables:


-- ft.code:
lang: ftd

\-- integer bar: 20


-- ft.markdown:

Declaring something new is now always `<type> <name>:`, both for variables, records
and components, as well as for fields and argument definition in records and
components.


-- ft.h1: Backward Compatibility Guarantee

We hope this was the last backward incompatible change. We are now going to become
very careful about backward compatibility. We are not yet 1.0, and we expect at
least one major backward incompatible change before we really are ready for
production, but we are now going to avoid it as much as we can.


-- ft.h1: UI As A Type

Arpita has implemented UI as a type. Now a component can take another ui element
as an argument. Till now they could only accept data types.


-- ft.code:
lang: ftd

\-- ftd.column foo:
ftd.ui a:
integer size: 10

\--- a:


-- ft.markdown:

We have introduced a new type, `ftd.ui`, the argument `a` for component `foo` here
has type `ftd.ui`.

Any ftd kernel component can be passed to someone expecting a `ftd.ui`.


-- ft.code:
lang: ftd

\-- foo:
a: ftd.text: hello


-- ft.markdown:

Here we are passing `ftd.text: hello` to `foo` as `a`. We have also implemented
what we call "continuation" to pass parameters:


-- ft.code:
lang: ftd

\-- foo:
a: ftd.text: hello
> size: 20
size: 12


-- ft.markdown:

Here we have passed `size` to both `foo`, `size: 12` goes to `foo`, and to
`ftd.text`, `> size: 20` means we are continuing from the previous line, and hence
`size: 20` is passed to `ftd.text`.

We can do arbitrary nesting this way.


-- ft.code:
lang: ftd

\-- foo:
a: foo:
> a: foo:
>> a: ftd.text: hello
>>> size: 12
>> size: 30
> size: 20
size: 12


-- ft.markdown:

And so on. Of course this makes things harder to understand, so use this with
that in mind, don't over do it, break down things into smaller components, code is
read way more often than it is written, a little bit of extra effort goes a long
way keeping things easy.


-- ft.h1: `$var` Everything Is Done

25th Nov 2021

We finished implementation of $ for all variable.


-- ft.h1: New Component Syntax

We are now working on unified component / variable declaration syntax. Currently
our components are defined like this:


-- ft.code:
lang: ftd

\-- ftd.text foo:
text: some text


-- ft.markdown:

We are now going to use the following syntax for the same:


-- ft.code:
lang: ftd

\-- ftd.text foo:
text: some text


-- ft.markdown:

As you can see its simpler. It aligns with how we declare a variable:


-- ft.code:
lang: ftd

\-- integer bar: 20


-- ft.h1: Components as type

Currently a component can only accept basic data types, like integer and string,
but not other components. We are now going to use component as type:


-- ft.code:
lang: ftd

\-- ftd.row foo:
ftd.text child:

\-- foo:
child: ftd.text: hello


-- ft.markdown:

Here we have `child` of type `ftd.text`.


-- ft.h2: Thoughts On UI Types

Can only kernel types be used for UI type or any component? Ideally we should be
able to specify a component, and any direct invocation of that component, or any
other component that uses that component as a base should be passed? What if I
wanted a `ftd.row`, but the component derived from a `ftd.row` is no longer
`row-like`? Why do I want a row specifically? It kind of does not make sense? Maybe
I want a container, in which case I may be adding children to that container, which
means I have to have generic types like `ftd.element`, which accepts any ui element,
or `ftd.container`, which accepts a container.

What about `ftd.image`? What if I want to say give me an image. I can pass any
instance ftd.image or instance of a component created directly or indirectly from
ftd.image. But what about a row that wraps an image? Should that row not be
accepted by a component that is expecting image? Why would any component want to
accept an image specifically?


-- ft.h1: Started FPM: FTD Package Manager

FTD is an awesome language, and it deserves a kick-ass package manager. Today you
can not launch a language without a package manager. So we have started working on
[`fpm`](/fpm/).


-- ft.h1: FTD Logo

Jay has created a logo for FTD that we like:


-- ft.image:
src: https://i.imgur.com/eaxBC1d.jpg
width: 300
align: center


-- ft.h1: `try.ftd.dev`

We movee `play.fifthtry.com` to [`try.ftd.dev`](https://try.ftd.dev),now that
`ftd` docs are moving to [`ftd.dev`](https://ftd.dev). They will still use
FifthTry, just the domain would be custom.


-- ft.h1: [`$var` Everything](/ftd/~/105/) Update

15th Nov 2021

Arpita has partially implemented `$var` everywhere change. As of now, global
variables can be referred using `$foo` syntax, no need to use `ref`. Also `@foo`
syntax is gone, any `$foo` is editable as well.

What she is working now is external variables, you can define a variable on top of
a component:


-- ft.code:
lang: ftd

\-- ftd.row:
$foo: boolean with default false


-- ft.markdown:

Once external variable is done she has to fix the `boolean with default false` syntax
and use `boolean $foo: false` or even `$foo: false` to declare a variable.


-- ft.h1: clean api CR

15th Nov 2021

Wrote about my thoughts on cleaning up FTD [public crate api](/ftd/~/108/).


-- ft.h1: `detached` support proposal

13th Nov 2021


-- ft.iframe:
src: https://www.loom.com/embed/07681c220abd4eb584c75327c686360b


-- ft.markdown:

Wrote up a [CR for `detached` components](/ftd/~/106/): components that are not
part of UI when created, and added a new `include` keyword to include any detached
component in "current container".


-- ft.h1: Started Journal

13th Nov 2021


-- ft.iframe:
src: https://www.loom.com/embed/dd33e35449f64963ac694155b3ed88e0


-- ft.markdown:

We have decided to start a journal for FTD. FTD has been under a lot of development
and its good for us to record our daily development.

We have been keeping a personal journal in FifthTry internal documentation, but
it would be better if it moved all FTD related things here for everyone's benefit.

We kind of believe in writing down our thoughts during all meetings as much as we
can, etc, a lot of stuff we write in change requests, linked from the Roadmap page.
But since they are all scattered across different CRs, its not easy to keep up
with what is going on with the project, so we kind of want to duplicate or link
here what is going on.

We also want to create a loom recording after the fact, just to capture a few more
things we might have missed when writing it down.


-- ft.h1: Fix: spacing issue

12th Nov 2021


-- ft.iframe:
src: https://www.loom.com/embed/23000f3b4fc442f988181c5ff65c7949


-- ft.markdown:

Consider the following code:


-- ft.code:
lang: ftd

\-- var show: true

\-- foo:

\--- ftd.text: Hello 👋
if: show

\--- ftd.text: World 🌎

\-- ftd.text: Click here!
$event-click$: toggle show

\-- component foo:
component: ftd.column
open: some-id

\--- ftd.text: Title

\--- ftd.row:
spacing: 20
id: some-id


-- ft.markdown:

This is how the DOM structure should look like:


-- ftd.scene:
height: 400


-- box:
left: 20
top: 20
width: 500
height: 300


-- text: `ftd.main` (`ftd.column`)
left: 290
top: 323


-- box:
left: 40
top: 40
width: 460
height: 200


-- text-box: Title
left: 55
top: 55


-- text: `ftd.row: some-id`
left: 300
top: 88


-- box:
width: 430
height: 80
top: 110
left: 55


-- text: `foo`
top: 215
left: 457


-- text-box: Hello 👋
top: 130
left: 70


-- text-box: World 🌎
top: 130
left: 200


-- ftd.text: Click Here!
top: 250
left: 45


-- ftd.text text:
caption text:
text: $text


-- ftd.column box:
string width:
width: $width
string height:
height: $height
border-width: 1
border-radius: 5
open: false


-- ftd.text text-box:
caption text:
text: $text
padding: 10
border-width: 1
border-radius: 5


-- container: page


-- boolean show: true


-- ft.markdown:

This is how it should look like:


-- foo:

--- ftd.text: Hello 👋
if: $show

--- ftd.text: World 🌎


-- ftd.text: Click here!
$event-click$: toggle $show


-- ftd.column foo:
open: some-id

--- ftd.text: Title

--- ftd.row:
spacing: 20
id: some-id


-- ft.markdown:

And this is how it used to look like:


-- ft.image:
src: https://i.imgur.com/7vypfBR.jpg
width: 130


-- ft.markdown:

There were two issues for proper rendering of the above code:

1. `--- ftd.text: Hello 👋` and `--- ftd.text: World 🌎` are two external children
of component `foo` and `foo` is open at `--- ftd.row:`. Earlier we used to wrap all
the external children in a column component (Why not row? no good reason just that
column is used a lot) and then attach this wrapper component to the desired place.
So this created a problem here. Instead of children appearing in a row-wise fashion,
it appears column-wise.

2. Also, open container `ftd.row` has `spacing: 20` which means all its children would
contain spacing from each other, except the first visible one, but here it has only
one wrapper child, so no spacing.


-- ft.h2: How have we solved this?

Just remove the wrapper and put all external children directly inside the desired
node. But how would we do reparenting of them (like in the case of event handling)?
Put a new attribute (`data-ext-id`) that has the same value in all the external
children and during reparenting, access children using this attribute.


-- ft.h2: Is everything solved?

Not yet. In the case of event-handling, what if the first child becomes invisible
or removed and so what about spacing then?

As we know there should be no space for the first element, so now that the first
child has vanished, the second child should act as the first one and space
should be removed. (And obviously, when the first child becomes visible again,
the second one should restore the spacing.)

Here's the solution. We have added a new attribute (`data-spacing`) in the
parent node that contains the spacing value. Every time this kind of event occurs,
we reevaluate spacing for its children.


-- ft.h2: Are we done now?

Yes, all problems are resolved. 🎉 🎊


-- ft.h1: Image link Fix

Fri, 12th Nov 2012

Consider the following code:


-- ft.code:
lang: ftd

\-- ftd.image:
src: https://www.w3schools.com/cssref/img_tree.gif
link: https://www.amitu.com/fifthtry/amitu/


-- ft.markdown:

Earlier, the link was not working. We just fixed this issue.


-- ft.h2: What was the issue?

For link we use `<a>` tag and for image we use `<img>` tag. `<img>` tag was
overriding `<a>`. Basically we were attaching `href` on top of `img` tag.


-- ft.h2: How have we resolved?

Now we create `<img>` tag and make it child of `<a>`.
